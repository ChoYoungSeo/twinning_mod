<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>twinning.twinning API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>twinning.twinning</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from twinning_cpp import twin_cpp, multiplet_S3_cpp, energy_cpp
import numpy as np
import math


def _data_format(data):
        const_cols = np.all(data == data[0, :], axis=0)
        data = data[:, np.invert(const_cols)]
        data = (data - data.mean(axis=0)) / data.std(axis=0)
        
        if data.data.c_contiguous:
                return data
        else:
                return np.copy(data, order=&#39;C&#39;)


def twin(data, r, u1=None, leaf_size=8):
        &#34;&#34;&#34;
        **Descritpion**

        ``twin()`` implements the data twinning algorithm presented in Vakayil and Joseph (2022). A partition of the dataset is returned, such that the resulting two disjoint sets, termed as *twins*, are distributed similar to each other, as well as the whole dataset. Such a partition is an optimal training-testing split (Joseph and Vakayil, 2021) for training and testing statistical and machine learning models, and is model-independent. The statistical similarity also allows one to treat either of the twins as a compression (lossy) of the dataset for tractable model building on Big Data.

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``r`` ( int ): an integer representing the inverse of the splitting ratio, e.g., for an 80-20 partition, ``r`` = 1 / 0.2 = 5

        ``u1`` ( int , optional ): index of the data point from where twinning starts; if not provided, twinning starts from a random point in the dataset; fixing ``u1`` makes twinning deterministic, i.e., the same twins are returned

        ``leaf_size`` ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree

        **Returns**

        ( ndarray ): indices of the smaller twin

        **Details**

        Before twinning, constant columns are removed from ``data`` and the remaining are scaled to zero mean and unit standard deviation. Twinning algorithm requires nearest neighbor queries that are performed using a *kd*-tree. The *kd*-tree implementation in the nanoflann (Blanco and Rai, 2014) C++ library is used.

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Joseph, V. R., &amp; Vakayil, A. (2021). SPlit: An Optimal Method for Data Splitting. Technometrics, 1-11. doi:10.1080/00401706.2021.1921037.

        Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. https://github.com/jlblancoc/nanoflann.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if u1 is None:
                u1 = np.random.randint(data.shape[0])
        elif u1 not in range(data.shape[0]):
                raise Exception(&#34;u1 should be a row index such that 0 &lt;= u1 &lt; data.shape[0]&#34;)

        if r not in range(2, math.floor(data.shape[0] / 2) + 1):
                raise Exception(&#34;r should be an integer such that 2 &lt;= r &lt;= data.shape[0]/2&#34;)
        
        data = _data_format(data)
        return np.array(twin_cpp(data, r, u1, leaf_size), dtype=&#39;uint64&#39;)


def multiplet(data, k, strategy=1, leaf_size=8):
        &#34;&#34;&#34;
        **Descritpion**

        ``multiplet()`` extends ``twin()`` to partition datasets into multiple statistically similar disjoint sets, termed as *multiplets*, under the three different strategies described in Vakayil and Joseph (2022).

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``k`` ( int ): the desired number of multiplets

        ``strategy`` ( int , optional ): an integer either 1, 2, or 3 referring to the three strategies for generating multiplets; strategy 2 perfroms best, but requires ``k`` to be a power of 2; strategy 3 is computatioanlly inexpensive, but performs worse than strategies 1 and 2

        ``leaf_size`` ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree

        **Returns**

        ( ndarray ): array with the multiplet id, ranging from 1 to ``k``, for each row in data

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. https://github.com/jlblancoc/nanoflann.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if k not in range(2, math.floor(data.shape[0] / 2) + 1):
                raise Exception(&#34;k should be an integer such that 2 &lt;= r &lt;= data.shape[0]/2&#34;)

        data = _data_format(data)
        N = data.shape[0]

        if strategy == 1:
                row_index = np.arange(N)
                folds = np.empty((0, 2))
                i = 0
                while True:
                        multiplet_i = np.array(twin_cpp(data, k - i, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                        fold = np.hstack((row_index[multiplet_i].reshape(len(multiplet_i), 1), np.repeat(i, len(multiplet_i)).reshape(len(multiplet_i), 1)))
                        folds = np.vstack((folds, fold))
                        
                        negate = np.ones(data.shape[0], bool)
                        negate[multiplet_i] = 0
                        data = data[negate, :]
                        row_index = row_index[negate]

                        if data.shape[0] &lt;= N / k:
                                fold = np.hstack((row_index.reshape(len(row_index), 1), np.repeat(i + 1, len(row_index)).reshape(len(row_index), 1)))
                                folds = np.vstack((folds, fold))
                                break

                        i += 1

                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)

        if strategy == 2:
                if not (k &amp; (k - 1) == 0):
                        raise Exception(&#34;strategy 2 requires k to be a power of 2&#34;)

                row_index = np.arange(N)
                folds = np.empty((0, 2))
                i = 0

                def equal_twins(data, row_index):
                        if data.shape[0] &lt;= math.ceil(N / k):
                                nonlocal folds, i
                                fold = np.hstack((row_index.reshape(len(row_index), 1), np.repeat(i, len(row_index)).reshape(len(row_index), 1)))
                                folds = np.vstack((folds, fold))
                                i += 1
                        else:
                                equal_twins_i = np.array(twin_cpp(data, 2, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                                negate = np.ones(data.shape[0], bool)
                                negate[equal_twins_i] = 0
                                equal_twins(data[negate, :], row_index[negate])
                                equal_twins(data[np.invert(negate), :], row_index[np.invert(negate)])

                equal_twins(data, row_index)
                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)

        if strategy == 3:
                sequence = np.array(multiplet_S3_cpp(data, k, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                folds = np.hstack((sequence.reshape(len(sequence), 1), np.tile(np.arange(k), np.ceil(N / k).astype(&#39;uint64&#39;))[0:N].reshape(N, 1)))
                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)


def energy(data, points):
        &#34;&#34;&#34;
        **Descritpion**

        ``energy()`` computes the energy distance (Székely and Rizzo, 2013) between a given dataset and a set of points in same dimensions.

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``points`` ( ndarray ): the set of points for which the energy distance with respect to ``data`` is to be computed; should not contain nan or infinity

        **Returns**

        ( float ): energy distance

        **Details**

        Smaller the energy distance, the more statistically similar the set of points is to the given dataset. The minimizer of energy distance is known as support points (Mak and Joseph, 2018), which is the basis for the twinning method. Computing energy distance between ``data`` and ``points`` involves Euclidean distance calculations among the rows of ``data``, among the rows of ``points``, and between the rows of ``data`` and ``points``. Since, ``data`` serves as the reference, the distance calculations among the rows of ``data`` are ignored for efficiency. Before computing the energy distance, the columns of ``data`` are scaled to zero mean and unit standard deviation. The mean and standard deviation of the columns of ``data`` are used to scale the respective columns in ``points``.

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Székely, G. J., &amp; Rizzo, M. L. (2013). Energy statistics: A class of statistics based on distances. Journal of statistical planning and inference, 143(8), 1249-1272.

        Mak, S. &amp; Joseph, V. R. (2018). Support Points. Annals of Statistics, 46, 2562-2592.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if type(points) != np.ndarray or len(points.shape) != 2:
                raise Exception(&#34;points is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(points).any() or np.isinf(points).any():
                raise Exception(&#34;points cannot contain nan or infinity&#34;)

        if data.shape[1] != points.shape[1]:
                raise Exception(&#34;data and points should have the same number of columns&#34;)

        const_cols = np.all(data == data[0, :], axis=0)
        data = data[:, np.invert(const_cols)]
        points = points[:, np.invert(const_cols)]

        data_mean = data.mean(axis=0)
        data_std = data.std(axis=0)
        data = (data - data_mean) / data_std
        points = (points - data_mean) / data_std

        if not data.data.c_contiguous:
                data = np.copy(data, order=&#39;C&#39;)

        if not points.data.c_contiguous:
                points = np.copy(points, order=&#39;C&#39;)

        return energy_cpp(data, points)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="twinning.twinning.energy"><code class="name flex">
<span>def <span class="ident">energy</span></span>(<span>data, points)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Descritpion</strong></p>
<p><code><a title="twinning.twinning.energy" href="#twinning.twinning.energy">energy()</a></code> computes the energy distance (Székely and Rizzo, 2013) between a given dataset and a set of points in same dimensions.</p>
<p><strong>Parameters</strong></p>
<p><code>data</code> ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity</p>
<p><code>points</code> ( ndarray ): the set of points for which the energy distance with respect to <code>data</code> is to be computed; should not contain nan or infinity</p>
<p><strong>Returns</strong></p>
<p>( float ): energy distance</p>
<p><strong>Details</strong></p>
<p>Smaller the energy distance, the more statistically similar the set of points is to the given dataset. The minimizer of energy distance is known as support points (Mak and Joseph, 2018), which is the basis for the twinning method. Computing energy distance between <code>data</code> and <code>points</code> involves Euclidean distance calculations among the rows of <code>data</code>, among the rows of <code>points</code>, and between the rows of <code>data</code> and <code>points</code>. Since, <code>data</code> serves as the reference, the distance calculations among the rows of <code>data</code> are ignored for efficiency. Before computing the energy distance, the columns of <code>data</code> are scaled to zero mean and unit standard deviation. The mean and standard deviation of the columns of <code>data</code> are used to scale the respective columns in <code>points</code>.</p>
<p><strong>References</strong></p>
<p>Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.</p>
<p>Székely, G. J., &amp; Rizzo, M. L. (2013). Energy statistics: A class of statistics based on distances. Journal of statistical planning and inference, 143(8), 1249-1272.</p>
<p>Mak, S. &amp; Joseph, V. R. (2018). Support Points. Annals of Statistics, 46, 2562-2592.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def energy(data, points):
        &#34;&#34;&#34;
        **Descritpion**

        ``energy()`` computes the energy distance (Székely and Rizzo, 2013) between a given dataset and a set of points in same dimensions.

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``points`` ( ndarray ): the set of points for which the energy distance with respect to ``data`` is to be computed; should not contain nan or infinity

        **Returns**

        ( float ): energy distance

        **Details**

        Smaller the energy distance, the more statistically similar the set of points is to the given dataset. The minimizer of energy distance is known as support points (Mak and Joseph, 2018), which is the basis for the twinning method. Computing energy distance between ``data`` and ``points`` involves Euclidean distance calculations among the rows of ``data``, among the rows of ``points``, and between the rows of ``data`` and ``points``. Since, ``data`` serves as the reference, the distance calculations among the rows of ``data`` are ignored for efficiency. Before computing the energy distance, the columns of ``data`` are scaled to zero mean and unit standard deviation. The mean and standard deviation of the columns of ``data`` are used to scale the respective columns in ``points``.

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Székely, G. J., &amp; Rizzo, M. L. (2013). Energy statistics: A class of statistics based on distances. Journal of statistical planning and inference, 143(8), 1249-1272.

        Mak, S. &amp; Joseph, V. R. (2018). Support Points. Annals of Statistics, 46, 2562-2592.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if type(points) != np.ndarray or len(points.shape) != 2:
                raise Exception(&#34;points is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(points).any() or np.isinf(points).any():
                raise Exception(&#34;points cannot contain nan or infinity&#34;)

        if data.shape[1] != points.shape[1]:
                raise Exception(&#34;data and points should have the same number of columns&#34;)

        const_cols = np.all(data == data[0, :], axis=0)
        data = data[:, np.invert(const_cols)]
        points = points[:, np.invert(const_cols)]

        data_mean = data.mean(axis=0)
        data_std = data.std(axis=0)
        data = (data - data_mean) / data_std
        points = (points - data_mean) / data_std

        if not data.data.c_contiguous:
                data = np.copy(data, order=&#39;C&#39;)

        if not points.data.c_contiguous:
                points = np.copy(points, order=&#39;C&#39;)

        return energy_cpp(data, points)</code></pre>
</details>
</dd>
<dt id="twinning.twinning.multiplet"><code class="name flex">
<span>def <span class="ident">multiplet</span></span>(<span>data, k, strategy=1, leaf_size=8)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Descritpion</strong></p>
<p><code><a title="twinning.twinning.multiplet" href="#twinning.twinning.multiplet">multiplet()</a></code> extends <code><a title="twinning.twinning.twin" href="#twinning.twinning.twin">twin()</a></code> to partition datasets into multiple statistically similar disjoint sets, termed as <em>multiplets</em>, under the three different strategies described in Vakayil and Joseph (2022).</p>
<p><strong>Parameters</strong></p>
<p><code>data</code> ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity</p>
<p><code>k</code> ( int ): the desired number of multiplets</p>
<p><code>strategy</code> ( int , optional ): an integer either 1, 2, or 3 referring to the three strategies for generating multiplets; strategy 2 perfroms best, but requires <code>k</code> to be a power of 2; strategy 3 is computatioanlly inexpensive, but performs worse than strategies 1 and 2</p>
<p><code>leaf_size</code> ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree</p>
<p><strong>Returns</strong></p>
<p>( ndarray ): array with the multiplet id, ranging from 1 to <code>k</code>, for each row in data</p>
<p><strong>References</strong></p>
<p>Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.</p>
<p>Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. <a href="https://github.com/jlblancoc/nanoflann.">https://github.com/jlblancoc/nanoflann.</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplet(data, k, strategy=1, leaf_size=8):
        &#34;&#34;&#34;
        **Descritpion**

        ``multiplet()`` extends ``twin()`` to partition datasets into multiple statistically similar disjoint sets, termed as *multiplets*, under the three different strategies described in Vakayil and Joseph (2022).

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``k`` ( int ): the desired number of multiplets

        ``strategy`` ( int , optional ): an integer either 1, 2, or 3 referring to the three strategies for generating multiplets; strategy 2 perfroms best, but requires ``k`` to be a power of 2; strategy 3 is computatioanlly inexpensive, but performs worse than strategies 1 and 2

        ``leaf_size`` ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree

        **Returns**

        ( ndarray ): array with the multiplet id, ranging from 1 to ``k``, for each row in data

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. https://github.com/jlblancoc/nanoflann.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if k not in range(2, math.floor(data.shape[0] / 2) + 1):
                raise Exception(&#34;k should be an integer such that 2 &lt;= r &lt;= data.shape[0]/2&#34;)

        data = _data_format(data)
        N = data.shape[0]

        if strategy == 1:
                row_index = np.arange(N)
                folds = np.empty((0, 2))
                i = 0
                while True:
                        multiplet_i = np.array(twin_cpp(data, k - i, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                        fold = np.hstack((row_index[multiplet_i].reshape(len(multiplet_i), 1), np.repeat(i, len(multiplet_i)).reshape(len(multiplet_i), 1)))
                        folds = np.vstack((folds, fold))
                        
                        negate = np.ones(data.shape[0], bool)
                        negate[multiplet_i] = 0
                        data = data[negate, :]
                        row_index = row_index[negate]

                        if data.shape[0] &lt;= N / k:
                                fold = np.hstack((row_index.reshape(len(row_index), 1), np.repeat(i + 1, len(row_index)).reshape(len(row_index), 1)))
                                folds = np.vstack((folds, fold))
                                break

                        i += 1

                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)

        if strategy == 2:
                if not (k &amp; (k - 1) == 0):
                        raise Exception(&#34;strategy 2 requires k to be a power of 2&#34;)

                row_index = np.arange(N)
                folds = np.empty((0, 2))
                i = 0

                def equal_twins(data, row_index):
                        if data.shape[0] &lt;= math.ceil(N / k):
                                nonlocal folds, i
                                fold = np.hstack((row_index.reshape(len(row_index), 1), np.repeat(i, len(row_index)).reshape(len(row_index), 1)))
                                folds = np.vstack((folds, fold))
                                i += 1
                        else:
                                equal_twins_i = np.array(twin_cpp(data, 2, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                                negate = np.ones(data.shape[0], bool)
                                negate[equal_twins_i] = 0
                                equal_twins(data[negate, :], row_index[negate])
                                equal_twins(data[np.invert(negate), :], row_index[np.invert(negate)])

                equal_twins(data, row_index)
                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)

        if strategy == 3:
                sequence = np.array(multiplet_S3_cpp(data, k, np.random.randint(data.shape[0]), leaf_size), dtype=&#39;uint64&#39;)
                folds = np.hstack((sequence.reshape(len(sequence), 1), np.tile(np.arange(k), np.ceil(N / k).astype(&#39;uint64&#39;))[0:N].reshape(N, 1)))
                return folds[np.argsort(folds[:, 0]), 1].astype(&#39;uint64&#39;)</code></pre>
</details>
</dd>
<dt id="twinning.twinning.twin"><code class="name flex">
<span>def <span class="ident">twin</span></span>(<span>data, r, u1=None, leaf_size=8)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Descritpion</strong></p>
<p><code><a title="twinning.twinning.twin" href="#twinning.twinning.twin">twin()</a></code> implements the data twinning algorithm presented in Vakayil and Joseph (2022). A partition of the dataset is returned, such that the resulting two disjoint sets, termed as <em>twins</em>, are distributed similar to each other, as well as the whole dataset. Such a partition is an optimal training-testing split (Joseph and Vakayil, 2021) for training and testing statistical and machine learning models, and is model-independent. The statistical similarity also allows one to treat either of the twins as a compression (lossy) of the dataset for tractable model building on Big Data.</p>
<p><strong>Parameters</strong></p>
<p><code>data</code> ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity</p>
<p><code>r</code> ( int ): an integer representing the inverse of the splitting ratio, e.g., for an 80-20 partition, <code>r</code> = 1 / 0.2 = 5</p>
<p><code>u1</code> ( int , optional ): index of the data point from where twinning starts; if not provided, twinning starts from a random point in the dataset; fixing <code>u1</code> makes twinning deterministic, i.e., the same twins are returned</p>
<p><code>leaf_size</code> ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree</p>
<p><strong>Returns</strong></p>
<p>( ndarray ): indices of the smaller twin</p>
<p><strong>Details</strong></p>
<p>Before twinning, constant columns are removed from <code>data</code> and the remaining are scaled to zero mean and unit standard deviation. Twinning algorithm requires nearest neighbor queries that are performed using a <em>kd</em>-tree. The <em>kd</em>-tree implementation in the nanoflann (Blanco and Rai, 2014) C++ library is used.</p>
<p><strong>References</strong></p>
<p>Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.</p>
<p>Joseph, V. R., &amp; Vakayil, A. (2021). SPlit: An Optimal Method for Data Splitting. Technometrics, 1-11. doi:10.1080/00401706.2021.1921037.</p>
<p>Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. <a href="https://github.com/jlblancoc/nanoflann.">https://github.com/jlblancoc/nanoflann.</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def twin(data, r, u1=None, leaf_size=8):
        &#34;&#34;&#34;
        **Descritpion**

        ``twin()`` implements the data twinning algorithm presented in Vakayil and Joseph (2022). A partition of the dataset is returned, such that the resulting two disjoint sets, termed as *twins*, are distributed similar to each other, as well as the whole dataset. Such a partition is an optimal training-testing split (Joseph and Vakayil, 2021) for training and testing statistical and machine learning models, and is model-independent. The statistical similarity also allows one to treat either of the twins as a compression (lossy) of the dataset for tractable model building on Big Data.

        **Parameters**

        ``data`` ( ndarray ): the dataset including both the predictors and response(s); should not contain nan or infinity

        ``r`` ( int ): an integer representing the inverse of the splitting ratio, e.g., for an 80-20 partition, ``r`` = 1 / 0.2 = 5

        ``u1`` ( int , optional ): index of the data point from where twinning starts; if not provided, twinning starts from a random point in the dataset; fixing ``u1`` makes twinning deterministic, i.e., the same twins are returned

        ``leaf_size`` ( int , optional ): maximum number of elements in the leaf-nodes of the kd-tree

        **Returns**

        ( ndarray ): indices of the smaller twin

        **Details**

        Before twinning, constant columns are removed from ``data`` and the remaining are scaled to zero mean and unit standard deviation. Twinning algorithm requires nearest neighbor queries that are performed using a *kd*-tree. The *kd*-tree implementation in the nanoflann (Blanco and Rai, 2014) C++ library is used.

        **References**

        Vakayil, A., &amp; Joseph, V. R. (2022). Data Twinning. Statistical Analysis and Data Mining: The ASA Data Science Journal, to appear. arXiv preprint arXiv:2110.02927.

        Joseph, V. R., &amp; Vakayil, A. (2021). SPlit: An Optimal Method for Data Splitting. Technometrics, 1-11. doi:10.1080/00401706.2021.1921037.

        Blanco, J. L. &amp; Rai, P. K. (2014). nanoflann: a C++ header-only fork of FLANN, a library for nearest neighbor (NN) with kd-trees. https://github.com/jlblancoc/nanoflann.

        &#34;&#34;&#34;

        if type(data) != np.ndarray or len(data.shape) != 2:
                raise Exception(&#34;data is expected to be a 2 dimensional numpy ndarray&#34;)

        if np.isnan(data).any() or np.isinf(data).any():
                raise Exception(&#34;data cannot contain nan or infinity&#34;)

        if u1 is None:
                u1 = np.random.randint(data.shape[0])
        elif u1 not in range(data.shape[0]):
                raise Exception(&#34;u1 should be a row index such that 0 &lt;= u1 &lt; data.shape[0]&#34;)

        if r not in range(2, math.floor(data.shape[0] / 2) + 1):
                raise Exception(&#34;r should be an integer such that 2 &lt;= r &lt;= data.shape[0]/2&#34;)
        
        data = _data_format(data)
        return np.array(twin_cpp(data, r, u1, leaf_size), dtype=&#39;uint64&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="twinning" href="index.html">twinning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="twinning.twinning.energy" href="#twinning.twinning.energy">energy</a></code></li>
<li><code><a title="twinning.twinning.multiplet" href="#twinning.twinning.multiplet">multiplet</a></code></li>
<li><code><a title="twinning.twinning.twin" href="#twinning.twinning.twin">twin</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>